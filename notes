1. Set up your enviroment by installing Flask, Flask-SQLAlchemy and put them in the requirements.txt file
2. create an api folder (inside the api folder, create a __init__.py (in the __init__.py file set up your server and set your enviroment variable in the terminal using export FLASK_APP=api/))
3. Install flask_restx which helps us build web api in flask by providing serilization, swagger UI etc. Then, pip freeze > requirements.txt
4. Creates the different parts of our application (in our case it is: auth,post,complains)
    Within our api folder, we will create three folders which are: auth, post, complains after this, we then create our views.py in all the folders created (ie, auth, complains, posts) to access the different parts of our application (This will be done using resources built in flask_restx). In the views.py file we then create our namespace which acts a blueprints.
5. After creating the name spaces, we go to our main init.py and import it to our server
6. After this, we then setup our configuration by creating a (config folder inside our api folder also, we create a __init__.py file and we create a file called config.py). Then within our config.py, we write classes to define our various configurations. iN THIS PROCESS, WE NEED TO INSTALL to pip install python_decouple. Then we pip freeze > requirements.txt. After this, we create .env file(for writing our enviroment variables). IN THE 
.env file, we get our secret key by writing python, import secrets, secrets.token_hex() and copy the key generated in the terminal.
7. After our configuration, we come to our init.py and set it up so we can use it within our application.
8. Then after all the configuration is been updated in our init.py file, we run our application. using flask run. But before doing this, we can create a simple scripts to run our application by creating a runserver.py outside our api folder.
9. After running all, we then create all API endpoints for the projects (we starts from the auth namespace, to the posts namespace then to the complains name space)
10. After creating this, we then set up our database to store our request of users and posts also with Flask-SQLAlchemy (which is an object relational mapper that helps us to keep track of our database by creating classes which will define our tables and access our databse rows as object to manipulate our data). we will then pip install flask_sqlalchemy and then pip freeze it to our requirements.txt file. Then after this, we create our SQLALCHEMY instance (so, we will classes which will acts as table (ORM) to help us access our databse rows). so, for this we will create and utils folder within our api folder. within utils, we also create an init.py file. Then within init.py we will create our db instance.Then after this, we will create our database modules which will define our tables (we will have three tables 1)user tbl 2)post tbl 3) enquiries tbl) ). To create this databse tables, within our api folder, we create models folder to house our database tables. Then within our models folder, we will create an init.py file, also, we will create our tables as a pyhton file (eg: users.py, posts.py and enquires.py). Then we start creating classes within this file to form our tables. After creating this tables, we then use flask_migrate to generate these tables(which hleps us keep track of our changes in tables with having to drop all our tables and re create). by pip installing flask_migrate and then pip freeze to requirements.txt file. Then after this, we will then head over to our main init.py file and import our db instance and database model after which we will hook it to our application server. After doing all these, we then go to our configuration to configure all databse we will use, so therefore we will head on to our config folder and inside we will locate our config.py and we will specify some configurations specific to sqlite.
After setting up our configuation in the config.py file, we will then head over to our main init.py file to create our databse by creating a context within our shell to allow us to access our databse modules and db instace so we can easily go ahead and create our database. After all this, we then head over to our terminal to create our db. First, we check if we still have flask app as our enviroment variable by using echo $FLASK_APP(api/). Then we will run "flask shell". After this, we create our database by using (db.create_all()).
After creating the database, we will then start our user registrattion via the end points we created by creating serilization etc. after this, we test our signup or add user route via insomia.
After creating and testing our user registration/signup route, we then create our Login endpoint or Flask-JWT-Extended route which allows user to login via their email and password and provide them with a JWT which will contain their identity so they can access the various protected endpoints. First, we need to pip - install a tool called "flask_jwt_extended" and freeze it to our requirements.txt file. Then we need to setup our API so, we can use our flask_jwt_extended therefore, we need to go back to our config.py and we check our config module then we set up our jwt lifespan. After configuring, then we need to setup our jwt extended within our flask application therefore, we go to main init.py file and we specify within our create_app() function that we want jwt_extended to work with our application. The we go back and work with our login endpoint. After creating our access and refresh token when a user has successfully logged in, we will need to create a new endpoint to helps us acquire a new access token when it has expired via a refresh token.
After this, we Create and Retrieve API resources by implementing other endpoints. such as creating and getting all posts and then, we test the end points on insomia
After this, we work on updating and deleting resources in the other endpoints.
After this, we move to error handling with werkzeug using our API handler method ( by creating our custom error handler which will take care of most of the default error handler we have been having) Therefore, we go to our main init.py and create the custom error handler
After this, we try to catch some of the errors within our models (such as sigup error etc.. using try and catch block)
After this, we create our test cases by going to our api folder and creating (tests folder in the tests folder, we will create our __init__.py and also, we will create test_posts, test_users, test_enquires etc based on models, that we have)